Definitive Guide to Architecting Autonomous Migration and Review Workflows in Windsurf IDE via Model Context Protocol1. Introduction: The Agentic Shift in Software EngineeringThe software development lifecycle (SDLC) is currently experiencing a foundational paradigm shift, transitioning from human-centric usage of passive tools to a collaborative model involving agentic orchestration. In this new era, the Integrated Development Environment (IDE) is no longer merely a text editor with syntax highlighting; it has evolved into a cognitive partner capable of understanding intent, reasoning about architectural dependencies, and executing complex, multi-step workflows. Windsurf IDE, developed by Codeium, stands at the vanguard of this evolution through its "Cascade" engine—an agentic system designed to maintain "Flow State" by integrating deep codebase understanding with real-time user actions.This report provides a comprehensive technical analysis and implementation strategy for constructing a sophisticated, closed-loop workflow within Windsurf. The objective is to automate legacy code migration, conduct rigorous Pull Request (PR) reviews, and enforce code quality standards. This is achieved not through simple prompt engineering, but through the architectural integration of the Model Context Protocol (MCP), a standardized interface that allows Large Language Models (LLMs) to interact with external data and tools securely.Specifically, we examine the deployment of a custom Retrieval-Augmented Generation (RAG) MCP system equipped with ten specialized tools—ranging from mcp2_check_ai_hallucinations to mcp2_parse_repository_graph—alongside a Bitbucket MCP integration. By harmonizing these tools within Windsurf’s markdown-based workflow definitions, we can create a system that not only generates code but validates it against a semantic knowledge graph, manages dependencies, and autonomously interacts with version control systems to provide "changes needed" reviews. This document serves as a blueprint for engineering teams seeking to elevate their migration strategies from manual refactoring to autonomous, verified transformation.2. The Architecture of Flow: Windsurf and Cascade2.1 The Cascade Engine: Trajectory-Based ReasoningAt the core of Windsurf lies Cascade, an agentic reasoning engine that differentiates itself from standard "copilots" through its ability to maintain a trajectory of thought. While traditional AI coding assistants often operate on a request-response basis—forgetting context between turns or limited to the immediate file—Cascade is architected to understand the broader narrative of the development task.In the context of a migration workflow, this distinction is critical. A migration is not a single atomic action; it is a sequence of interdependent steps involving discovery, analysis, transformation, and verification. Cascade’s architecture supports this by maintaining a persistent "memory" of the plan, allowing it to execute workflows that span multiple files and leverage external tools without losing the original intent. The "Flow" paradigm ensures that the agent creates a deep contextual awareness, indexing not just the syntax of the code but the semantic relationships between modules, which is essential when utilizing tools like mcp2_parse_repository_graph.2.2 Deep Contextual Awareness and Local IndexingWindsurf achieves its high fidelity in code generation through deep contextual awareness. Unlike cloud-based models that may only see snippets of code, Windsurf creates a comprehensive index of the local codebase. This local indexing acts as the immediate memory bank for the agent, allowing it to perform "Codebase Search" and "Grep Search" natively.However, for enterprise-grade migrations, local text indexing is insufficient. Complex refactoring requires understanding the structure of the code—inheritance hierarchies, dependency graphs, and architectural patterns. This is where the integration of the custom RAG MCP system becomes indispensable. By offloading the structural analysis to specialized tools like mcp2_query_knowledge_graph, Windsurf extends its native capabilities, effectively borrowing the "brain" of a static analysis engine to guide its probabilistic generation.2.3 The Role of Markdown-Based WorkflowsWindsurf creates a bridge between unstructured natural language and structured automation through markdown-based workflows. Stored in .windsurf/workflows/, these files are not passive documentation but executable scripts that guide Cascade through specific trajectories.These workflows support:Sequential Execution: Defining a precise order of operations (e.g., "Analyze dependencies first, then modify code").Tool Chaining: passing the output of one MCP tool (e.g., mcp2_get_file_dependencies) as the input context for another (e.g., mcp2_search_semantic_code).Conditional Logic: Implementing "If/Then" gates based on tool feedback (e.g., "If mcp2_check_ai_hallucinations detects errors, do not commit").Checkpoints and Gates: Allowing for human-in-the-loop verification before irreversible actions are taken, a necessary safety valve for autonomous migration.3. The Model Context Protocol (MCP): Infrastructure for Autonomy3.1 Protocol Fundamentals and TopologyThe Model Context Protocol (MCP) serves as the "USB-C for AI applications," creating a standardized way for AI clients (like Windsurf) to connect to diverse servers (like Bitbucket or a custom RAG system). This protocol abstracts the complexity of API integrations, allowing the IDE to treat a complex Knowledge Graph query or a Bitbucket Pull Request fetch as a standardized "Tool Call".The topology for the user's requested workflow involves a "Star" configuration:Host: Windsurf IDE.Client: Cascade Agent.Server A (RAG System): A custom Python or Node.js server exposing the mcp2_* toolset, likely backed by a Graph Database (like Neo4j) and a Vector Store.Server B (Bitbucket): An integration server connecting to the Atlassian Bitbucket API for source control management.3.2 Secure Configuration and Transport LayersConnecting these components requires a rigorous configuration strategy, primarily managed through the mcp_config.json file. Windsurf supports both stdio (standard input/output) and sse (Server-Sent Events) transport layers.For the local RAG system, a stdio transport is often preferred for latency and security, as the data never leaves the local machine's process boundary. For the Bitbucket integration, depending on the implementation, it may interface with a remote API but run as a local proxy.Security Implication: The prompt indicates the use of powerful tools like mcp2_read_full_file and Bitbucket write access. Security best practices dictate that these capabilities must be gated. Windsurf allows for environment variable interpolation (${env:VAR}) in the config file, ensuring that API keys for the RAG system and Bitbucket are not hardcoded in the repository.3.3 The Custom Tool EcosystemThe effectiveness of the migration workflow hinges entirely on the granularity and utility of the tools exposed by the MCP servers. The user has provided a specific list of ten mcp2 tools. We must analyze these not just as function calls, but as cognitive extensions of the agent.Tool NameCognitive Function in MigrationUnderlying Mechanismmcp2_parse_repository_graphStructural AwarenessGenerates an AST or call graph to map entity relationships, far superior to regex search for refactoring.mcp2_query_knowledge_graphArchitectural ReasoningAllows semantic queries against the graph (e.g., "Find all controllers inheriting from BaseController") to ensure pattern consistency.mcp2_check_ai_hallucinationsMeta-Cognitive VerificationA self-correction mechanism that cross-references generated code against the known schema to detect non-existent APIs.mcp2_check_dependency_usageImpact AnalysisVerifies that new imports are valid and do not introduce circular dependencies or bloat.mcp2_get_file_dependenciesContext ScopingIdentifies exactly which files need to be loaded into context before editing a target file.mcp2_get_project_infoEnvironmental GroundingRetrieves metadata (framework versions, build systems) to prevent version mismatch errors.mcp2_read_full_fileDeep ReadingProvides the complete content of a file when partial context is insufficient.mcp2_search_code_examplesFew-Shot PromptingRetrieves "gold standard" examples from the RAG system to guide code generation style.mcp2_search_exact_matchPrecision RetrievalLocates specific symbol definitions or constants.mcp2_search_semantic_codeIntent DiscoveryFinds code based on meaning (e.g., "authentication logic") rather than keywords.4. Deep Analysis of the RAG MCP ToolsetTo effectively orchestrate these tools, we must understand their operational theory. The prefix mcp2 suggests a versioned or specialized namespace for this specific RAG system.4.1 Knowledge Graph Integration (parse_repository_graph, query_knowledge_graph)The inclusion of graph-based tools indicates an advanced "GraphRAG" approach. Standard RAG relies on vector similarity, which is excellent for finding semantically related text but poor at understanding structural hierarchy (e.g., "Class A inherits from Class B which implements Interface C").mcp2_parse_repository_graph: This tool likely performs a static analysis of the codebase, extracting nodes (classes, functions, variables) and edges (calls, inherits, imports). In a migration workflow, this is the "Surveyor." Before upgrading a library, the agent uses this tool to map every location where the library is instantiated.mcp2_query_knowledge_graph: This acts as the interface to the graph data. It allows the agent to ask complex questions like "What is the impact radius of modifying UserDTO?". By integrating this into the workflow, we prevent "blind refactoring" where the agent fixes one file but breaks five others that depend on it in ways not immediately visible in the file's text.4.2 Hallucination Control (check_ai_hallucinations)This is perhaps the most critical tool for automated coding. LLMs are probabilistic engines that can confidently invent plausible but non-existent function names (hallucinations).Mechanism: This tool likely takes a snippet of generated code and verifies every symbol against the Knowledge Graph or the compiler/linter output. If the agent invents utils.parseDateString() but the actual method is utils.dateParse(), this tool flags it.Workflow Integration: This tool functions as a "Quality Gate." In the workflow logic, it should be invoked immediately after code generation and before any commit or PR action. If it returns a failure, the workflow loop should force the agent to regenerate the code using the error message as feedback.4.3 Semantic and Example-Based Searchmcp2_search_code_examples: This tool operationalizes "Few-Shot Learning." Instead of relying on the model's training data (which might be outdated), the agent retrieves verified examples from the project's own codebase or a curated snippets library. This ensures that the migration adheres to the current team coding standards, not generic internet standards.mcp2_search_semantic_code: This is vital for finding logic that needs migration but doesn't follow a strict naming convention. For example, finding all "retry logic" to replace it with a new ResiliencePolicy wrapper, even if the legacy code uses while loops, for loops, or goto statements.5. Bitbucket MCP Integration: Bridging Local and RemoteThe user requires the workflow to "give PR reviews" and "fetch Bitbucket data." This requires a robust Bitbucket MCP server. Based on standard implementations (like the Atlassian official or community versions), this integration exposes the remote VCS state to the local agent.5.1 Capability MappingThe Bitbucket MCP provides specific tools that map to the user's requirements:Fetch Data: bb_get_pr (or get_pull_request) retrieves the title, description, and, crucially, the diff of the pull request.Review: bb_add_comment (or add_comment) allows the agent to post general feedback or file-level comments.Changes Needed: The logic for "review with changes needed" is derived from the analysis of the diff, which is then enacted by posting a comment requesting changes or explicitly setting the PR status if the tool supports it (e.g., request_changes).5.2 The Review Loop MechanicsThe "Review" workflow is distinct from migration. It involves:Fetching Context: Using bb_get_pr to get the code changes.Hydrating Context: Using mcp2_read_full_file locally to see the full file context of the changed lines (since diffs often lack sufficient context for deep analysis).Analysis: Using mcp2_check_ai_hallucinations and mcp2_check_dependency_usage on the proposed code in the PR to verify it doesn't break the build or introduce hallucinations.Feedback: Posting the results back to Bitbucket.6. Architecting the Workflow: A Step-by-Step ImplementationWe will now synthesize these components into a unified Windsurf workflow. This workflow is defined in a markdown file (e.g., .windsurf/workflows/comprehensive-migration.md). The markdown syntax in Windsurf serves as the "programming language" for the agent, supporting instructional steps, conditional branching, and tool invocation.6.1 Configuration Prerequisites (mcp_config.json)First, ensure the mcp_config.json is correctly set up to load both the Bitbucket and Custom RAG servers.JSON{
  "mcpServers": {
    "bitbucket": {
      "command": "npx",
      "args": ["-y", "@aashari/mcp-server-atlassian-bitbucket"],
      "env": {
        "BITBUCKET_USERNAME": "${env:BITBUCKET_USER}",
        "BITBUCKET_APP_PASSWORD": "${env:BITBUCKET_PASS}"
      }
    },
    "rag-system": {
      "command": "python3",
      "args": ["/path/to/rag_mcp/server.py"],
      "env": {
        "GRAPH_URI": "${env:NEO4J_URI}",
        "API_KEY": "${env:RAG_API_KEY}"
      }
    }
  }
}
Note: The specific command for the RAG system depends on how the mcp2 tools are packaged (e.g., a Python script, a Docker container, or an NPM package). The above assumes a local Python execution.6.2 Workflow Design Pattern: The "Verify-Act-Verify" LoopThe workflow is designed with a defensive programming mindset. It never assumes the agent's output is correct; it explicitly schedules verification steps using the mcp2 tools.Logic Gates and Checkpoints:Checkpoint: A pause in execution where the agent summarizes the plan and waits for user confirmation.Conditional Logic: "If mcp2_check_ai_hallucinations finds errors, THEN iterate fix, ELSE proceed.".6.3 The Workflow Definition (Markdown)Below is the complete, executable markdown content for the workflow file. This should be saved as .windsurf/workflows/migration-and-review.md.Migration and Review AssistantDescription: A comprehensive workflow for migrating legacy code, verifying changes via Knowledge Graph, and performing automated PR reviews with "Changes Needed" feedback.Phase 1: Contextual Discovery & PlanningInitialize Project ContextCall mcp2_get_project_info to load build system, framework versions, and environment details.Call mcp2_parse_repository_graph to index the current state of the codebase and build a fresh dependency graph.Analyze Migration TargetsAsk the user: "What is the specific goal of this migration? (e.g., 'Migrate javax to jakarta', 'Refactor Auth Controller')."Based on the user's input, use mcp2_search_semantic_code to identify all relevant files and code segments requiring modification.For each identified file, call mcp2_get_file_dependencies to understand the impact radius of changes.Generate Migration PlanSynthesize the gathered information into a step-by-step plan.CHECKPOINT: Present the list of files to be modified and the proposed architectural changes. Wait for user approval before modifying any code.Phase 2: Execution & Self-CorrectionIterative RefactoringFor EACH file in the approved plan:Context Loading: Call mcp2_read_full_file to load the target file content.Guidance Retrieval: Call mcp2_search_code_examples to fetch the "Gold Standard" implementation patterns for the new architecture.Drafting: Modify the code to implement the migration logic.Immediate Verification:Call mcp2_check_ai_hallucinations on the newly written code segments.Call mcp2_check_dependency_usage to ensure no forbidden or circular dependencies were introduced.Conditional Correction:IF hallucinations or dependency issues are detected:Analyze the error report from the tools.Use mcp2_search_exact_match or mcp2_query_knowledge_graph to find the correct API symbols.Rewrite the code to fix the issues.Re-run verification (Max 3 retries).IF verification passes:Save the file and proceed to the next one.Local ValidationRun local tests (via terminal command appropriate for the project, e.g., npm test, pytest).If tests fail, use the error output to perform a repair cycle on the modified files.Phase 3: Bitbucket PR Review & SubmissionPull Request ManagementCall bb_ls_prs (Bitbucket) to check if a PR already exists for the current branch.IF a PR exists:Call bb_get_pr to fetch the current diff and description.Compare the PR implementation against the mcp2_query_knowledge_graph architectural rules.Review Logic:IF the code violates strict architectural patterns (verified by mcp2 tools) OR fails the hallucination check:Draft a review comment detailing specific violations.Use bb_add_comment to post the review.Explicitly state "Changes Needed" in the summary.IF the code passes all checks:Post a "LGTM" (Looks Good To Me) comment with a summary of the validation steps performed.IF no PR exists:Ask the user if they wish to create a PR using bb_create_pr.Final SummaryGenerate a report summarizing:Files migrated.Verification results (Hallucination checks, Dependency checks).Link to the Bitbucket PR (if applicable).6.4 Detailed Breakdown of Workflow Logic6.4.1 The "Checkpoint" MechanismIn Step 3, the explicit instruction "CHECKPOINT" leverages Windsurf's capability to pause the agentic loop. This is a safety feature. Automated migrations can be destructive; by forcing the agent to present a plan and wait, we ensure the developer consents to the scope of changes. This prevents the "runaway agent" scenario where the IDE rewrites the entire codebase incorrectly.6.4.2 The "Hallucination Loop" (Step 4)This is the most advanced component. It implements a "Reflection" pattern.Draft: The LLM generates code based on its training data.Verify: The mcp2_check_ai_hallucinations tool acts as a "ground truth" oracle. It checks if the symbols used in the draft actually exist in the knowledge graph.Correct: If the tool says "Function X does not exist," the agent uses mcp2_search_exact_match to find the real function name.
This minimizes the "works on my machine" syndrome and ensures high compilation success rates.6.4.3 The "Changes Needed" Logic (Step 6)The prompt specifically requested "review with changes needed." This is implemented via conditional logic in Step 6. The workflow does not just "review"; it audits. By using mcp2_query_knowledge_graph during the review phase, the agent acts as a Senior Engineer enforcing architectural invariants (e.g., "Domain entities must not depend on Infrastructure layer"). If a violation is found, the workflow directs the agent to leave a corrective comment rather than a passive approval.7. Implementation Strategy and Best Practices7.1 Directory StructureTo make this workflow discoverable and operational, the following directory structure is recommended:.windsurf/├── mcp_config.json          # (Or in global user settings)├── workflows/│   └── migration-review.md  # The workflow definition├── rules/│   └── migration-rules.md   # Global rules for migration style└── memories/                # Persistent context storage7.2 The Role of AGENTS.mdIn addition to the workflow file, creating an AGENTS.md file in the root of the repository can provide "always-on" context. This file should contain high-level directives that apply to all Cascade interactions, such as:"Always run mcp2_check_dependency_usage before suggesting new imports.""Prefer functional programming patterns as defined in mcp2_search_code_examples."This ensures that even if the user interacts with Cascade outside of the strict /migrate workflow, the agent still adheres to the project's core principles.7.3 Managing Token Limits and LatencyWorkflows that involve reading full files and parsing graphs can be token-intensive.Optimization: The workflow is designed to use mcp2_parse_repository_graph (metadata) first, and mcp2_read_full_file (content) only when necessary. This "lazy loading" approach conserves context window space.Latency: Calling external MCP tools adds latency. Users should be aware that the "Verification" steps in the workflow may take several seconds to complete as the RAG system processes the graph queries.7.4 Security and PermissionsGranting an AI agent access to mcp2_read_full_file and Bitbucket write permissions creates a potential blast radius.Mitigation 1: Use scoped Bitbucket App Passwords with minimal necessary permissions (e.g., repository:write, pullrequest:write).Mitigation 2: The "Approval Gate" in the workflow prevents the agent from pushing code to the remote repository without explicit user confirmation.Mitigation 3: Ensure the RAG MCP server runs in a containerized environment or a restricted user space to prevent local system escalation.8. ConclusionBy integrating the Model Context Protocol into Windsurf's Cascade engine, we transform the IDE from a passive tool into an active participant in the engineering process. The workflow defined in this report leverages the specific capabilities of the mcp2 toolset to solve the two biggest challenges in AI-assisted coding: Hallucination and Context Loss.Through mcp2_parse_repository_graph, the agent gains structural understanding. Through mcp2_check_ai_hallucinations, it gains self-correction capabilities. Through the Bitbucket integration, it gains operational agency. The resulting workflow provides a robust, verified, and scalable method for migrating legacy codebases, ensuring that the speed of AI generation does not come at the cost of architectural integrity. This is not just automation; it is the realization of the "Agentic IDE" promise.
